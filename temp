public class PlaceholderResolver {

    public static void main(String[] args) {
        // Example usage
        MyClass myClassInstance = new MyClass();
        AnotherClass anotherInstance = new AnotherClass();
        anotherInstance.level1.level2.level3 = "DeepResolvedValue";

        // Create lists and maps as arguments
        List<String> stringList = List.of("Element1", "Element2", "Element3");
        Map<String, String> stringMap = Map.of("Key1", "Value1", "Key2", "Value2");

        // Example text with multiple placeholders, including nested field paths and method calls
        String textWithPlaceholders = "{0}.size() and Nested field value is {1}.foo.bar.size() and Simple value is {1}";

        try {
            String resolvedText = resolvePlaceholders(new Object[]{stringList, anotherInstance}, textWithPlaceholders);
            System.out.println("Resolved Text: " + resolvedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Resolves placeholders in the given text using the provided parameters.
     *
     * @param params The array of parameters to substitute in the text.
     * @param text   The text containing placeholders.
     * @return The text with placeholders resolved to actual values.
     * @throws Exception If there is an error resolving the placeholders.
     */
    public static String resolvePlaceholders(Object[] params, String text) throws Exception {
        // Pattern to match placeholders like {0}.size() or {1}.foo.bar.size()
        Pattern pattern = Pattern.compile("\\{(\\d+)\\}(\\.([\\w\\(\\)\\.]+))?");
        Matcher matcher = pattern.matcher(text);
        StringBuffer result = new StringBuffer();

        // Find and process each placeholder
        while (matcher.find()) {
            int index = Integer.parseInt(matcher.group(1));
            String fieldPath = matcher.group(2);

            if (fieldPath != null) {
                // Resolve the field value or method result
                String resolvedValue = resolveFieldOrMethod(params[index], fieldPath);
                matcher.appendReplacement(result, resolvedValue);
            } else {
                // Handle simple object reference like {1}
                String resolvedValue = params[index].toString();
                matcher.appendReplacement(result, resolvedValue);
            }
        }
        matcher.appendTail(result);

        return result.toString();
    }

    /**
     * Resolves a field path or method call on an object using reflection.
     *
     * @param obj       The object to resolve the field path or method call on.
     * @param fieldPath The field path or method call (e.g., "foo.bar.size()").
     * @return The string representation of the resolved value.
     * @throws Exception If there is an error resolving the field or invoking the method.
     */
    public static String resolveFieldOrMethod(Object obj, String fieldPath) throws Exception {
        String[] fields = fieldPath.split("\\.");
        Object currentObject = obj;

        for (String field : fields) {
            if (field.endsWith("()")) {
                // It's a method call
                String methodName = field.substring(0, field.length() - 2);
                currentObject = invokeMethod(currentObject, methodName);
            } else {
                // It's a field access
                currentObject = getFieldValue(currentObject, field);
            }
        }

        return currentObject.toString();
    }

    /**
     * Gets the string representation of a field value from an object using reflection.
     *
     * @param obj   The object to get the field value from.
     * @param field The field name.
     * @return The string representation of the field value.
     * @throws Exception If there is an error accessing the field.
     */
    public static String getFieldValue(Object obj, String field) throws Exception {
        Field declaredField = obj.getClass().getDeclaredField(field);
        declaredField.setAccessible(true);
        Object value = declaredField.get(obj);
        return String.valueOf(value);
    }

    /**
     * Invokes a method on an object using reflection.
     *
     * @param obj        The object on which to invoke the method.
     * @param methodName The name of the method to invoke.
     * @return The string representation of the method invocation result.
     * @throws Exception If there is an error invoking the method.
     */
    public static Object invokeMethod(Object obj, String methodName) throws Exception {
        Method method = obj.getClass().getMethod(methodName);
        return method.invoke(obj);
    }
}
