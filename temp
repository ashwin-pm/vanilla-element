/**
 * A utility class for resolving placeholders in text using JEXL expressions.
 * 
 * This class provides a method to replace placeholders in a text with values
 * derived from provided parameters. The placeholders support nested fields 
 * and method calls.
 *
 * Example usage:
 * <pre>
 *     MyClass myClassInstance = new MyClass();
 *     AnotherClass anotherClassInstance = new AnotherClass();
 *     String textWithPlaceholders = "Field value: {0}.foo and List size: {1}.myObject.fooList.size()";
 *     String resolvedText = JexlPlaceholderResolver.resolvePlaceholders(new Object[]{myClassInstance, anotherClassInstance}, textWithPlaceholders);
 *     System.out.println("Resolved Text: " + resolvedText);
 * </pre>
 * 
 * @see MyClass
 * @see AnotherClass
 * @see org.apache.commons.jexl3.JexlEngine
 * @see org.apache.commons.jexl3.JexlContext
 * @see org.apache.commons.jexl3.JexlExpression
 * 
 * @author
 */

/**
 * Resolves placeholders in the given text using the provided parameters.
     *
     * The method supports the following types of placeholders:
     * - `{n}`: Direct access to the nth parameter (0-based index).
     * - `{n}.field`: Access to a public field of the nth parameter.
     * - `{n}.method()`: Invocation of a public method with no arguments of the nth parameter.
     * - `{n}.field.method()`: Access to a field followed by a method invocation.
     * - `{n}.field1.field2`: Nested field access.
     * - `{n}.field1.field2.method()`: Nested field access followed by a method invocation.
     * 
     * Example messages:
     * - "Direct field access: {0}.foo"
     * - "Nested field access: {1}.myObject.foo"
     * - "Method call on field: {0}.fooList.size()"
     * - "Direct method call: {1}.myObject.fooList.size()"
     * Resolves placeholders in the given text using the provided parameters.
     *
     * @param params The array of parameters to substitute in the text.
     * @param text   The text containing placeholders.
     * @return The text with placeholders resolved to actual values.
     * @throws Exception If there is an error resolving the placeholders.
     */
    public static String resolvePlaceholders(Object[] params, String text) throws Exception {
        // Pattern to match placeholders like {0}.size() or {1}.level1.level2.bar.size()
        Pattern pattern = Pattern.compile("\\{(\\d+)\\}(\\.([\\w\\(\\)\\.]+))?");
        Matcher matcher = pattern.matcher(text);
        StringBuffer result = new StringBuffer();

        // Find and process each placeholder
        while (matcher.find()) {
            int index = Integer.parseInt(matcher.group(1));
            String fieldPath = matcher.group(2);

            if (fieldPath != null) {
                // Resolve the field value or method result
                String resolvedValue = resolveFieldOrMethod(params[index], fieldPath.substring(1));
                matcher.appendReplacement(result, resolvedValue);
            } else {
                // Handle simple object reference like {1}
                String resolvedValue = params[index].toString();
                matcher.appendReplacement(result, resolvedValue);
            }
        }
        matcher.appendTail(result);

        return result.toString();
    }

    /**
     * Resolves a field path or method call on an object using reflection.
     *
     * @param obj       The object to resolve the field path or method call on.
     * @param fieldPath The field path or method call (e.g., "level1.level2.bar.size()").
     * @return The string representation of the resolved value.
     * @throws Exception If there is an error resolving the field or invoking the method.
     */
    public static String resolveFieldOrMethod(Object obj, String fieldPath) throws Exception {
        String[] fields = fieldPath.split("\\.");
        Object currentObject = obj;

        for (String field : fields) {
            if (field.endsWith("()")) {
                // It's a method call
                String methodName = field.substring(0, field.length() - 2);
                if ("size".equals(methodName) && (currentObject instanceof List || currentObject instanceof Map)) {
                    currentObject = invokeSizeMethod(currentObject);
                } else {
                    currentObject = invokeMethod(currentObject, methodName);
                }
            } else {
                // It's a field access
                currentObject = getFieldValue(currentObject, field);
            }
        }

        return currentObject.toString();
    }

    /**
     * Gets the field value from an object using reflection.
     *
     * @param obj   The object to get the field value from.
     * @param field The field name.
     * @return The field value.
     * @throws Exception If there is an error accessing the field.
     */
    public static Object getFieldValue(Object obj, String field) throws Exception {
        Field declaredField = obj.getClass().getDeclaredField(field);
        declaredField.setAccessible(true);
        return declaredField.get(obj);
    }

    /**
     * Invokes a method on an object using reflection.
     *
     * @param obj        The object on which to invoke the method.
     * @param methodName The name of the method to invoke.
     * @return The result of the method invocation.
     * @throws Exception If there is an error invoking the method.
     */
    public static Object invokeMethod(Object obj, String methodName) throws Exception {
        Method method = obj.getClass().getMethod(methodName);
        return method.invoke(obj);
    }

    /**
     * Invokes the size method on a List or Map object.
     *
     * @param obj The List or Map object.
     * @return The size of the List or Map.
     * @throws Exception If there is an error invoking the method.
     */
    public static Object invokeSizeMethod(Object obj) throws Exception {
        if (obj instanceof List) {
            return ((List<?>) obj).size();
        } else if (obj instanceof Map) {
            return ((Map<?, ?>) obj).size();
        } else {
            throw new IllegalArgumentException("Object is not a List or Map");
        }
    }



dependencies {
    implementation 'org.apache.camel.springboot:camel-spring-boot-starter:3.11.0' // Use the appropriate version
    implementation 'org.apache.camel.springboot:camel-opentelemetry-starter:3.11.0' // Use the appropriate version
    implementation 'io.opentelemetry:opentelemetry-api:1.5.0' // Use the appropriate version
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-aop'
    implementation 'org.springframework.cloud:spring-cloud-starter-sleuth:3.0.4' // Use the appropriate version
    implementation 'org.springframework.cloud:spring-cloud-sleuth-otel-autoconfigure:1.0.0' // Use the appropriate version
}

<dashboard>
  <label>Method Execution Time Dashboard</label>
  <description>Dashboard to monitor method execution times and drill down to detailed logs.</description>
  <row>
    <panel>
      <input type="time" token="time_range">
        <default>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
        </default>
      </input>
    </panel>
  </row>
  <row>
    <panel>
      <title>Execution Time Statistics by Method</title>
      <chart>
        <search>
          <query>
            index=&lt;your_index&gt; sourcetype=&lt;your_sourcetype&gt; earliest=$time_range.earliest$ latest=$time_range.latest$ 
            | rex field=_raw "start\[\&lt;start&gt;\d+\] time\[\&lt;execution_time&gt;\d+\] tag\[\&lt;tag&gt;[^\]]+\] message\[\&lt;message&gt;[^\]]+\]"
            | stats min(execution_time) as min_time max(execution_time) as max_time avg(execution_time) as avg_time by tag
          </query>
        </search>
        <option name="charting.chart">column</option>
        <option name="charting.series">multi</option>
      </chart>
      <drilldown>
        <set token="selected_tag">$row.tag$</set>
      </drilldown>
    </panel>
  </row>
  <row>
    <panel>
      <title>Detailed Logs for Selected Method</title>
      <table>
        <search>
          <query>
            index=&lt;your_index&gt; sourcetype=&lt;your_sourcetype&gt; earliest=$time_range.earliest$ latest=$time_range.latest$ tag=$selected_tag$ 
            | rex field=_raw "start\[\&lt;start&gt;\d+\] time\[\&lt;execution_time&gt;\d+\] tag\[\&lt;tag&gt;[^\]]+\] message\[\&lt;message&gt;[^\]]+\]"
            | table _time execution_time tag message
          </query>
        </search>
      </table>
    </panel>
  </row>
</dashboard>


