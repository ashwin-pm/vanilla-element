/**
     * Resolves placeholders in the given text using the provided parameters.
     *
     * @param params The array of parameters to substitute in the text.
     * @param text   The text containing placeholders.
     * @return The text with placeholders resolved to actual values.
     * @throws Exception If there is an error resolving the placeholders.
     */
    public static String resolvePlaceholders(Object[] params, String text) throws Exception {
        // Pattern to match placeholders like {0}.size() or {1}.level1.level2.bar.size()
        Pattern pattern = Pattern.compile("\\{(\\d+)\\}(\\.([\\w\\(\\)\\.]+))?");
        Matcher matcher = pattern.matcher(text);
        StringBuffer result = new StringBuffer();

        // Find and process each placeholder
        while (matcher.find()) {
            int index = Integer.parseInt(matcher.group(1));
            String fieldPath = matcher.group(2);

            if (fieldPath != null) {
                // Resolve the field value or method result
                String resolvedValue = resolveFieldOrMethod(params[index], fieldPath.substring(1));
                matcher.appendReplacement(result, resolvedValue);
            } else {
                // Handle simple object reference like {1}
                String resolvedValue = params[index].toString();
                matcher.appendReplacement(result, resolvedValue);
            }
        }
        matcher.appendTail(result);

        return result.toString();
    }

    /**
     * Resolves a field path or method call on an object using reflection.
     *
     * @param obj       The object to resolve the field path or method call on.
     * @param fieldPath The field path or method call (e.g., "level1.level2.bar.size()").
     * @return The string representation of the resolved value.
     * @throws Exception If there is an error resolving the field or invoking the method.
     */
    public static String resolveFieldOrMethod(Object obj, String fieldPath) throws Exception {
        String[] fields = fieldPath.split("\\.");
        Object currentObject = obj;

        for (String field : fields) {
            if (field.endsWith("()")) {
                // It's a method call
                String methodName = field.substring(0, field.length() - 2);
                if ("size".equals(methodName) && (currentObject instanceof List || currentObject instanceof Map)) {
                    currentObject = invokeSizeMethod(currentObject);
                } else {
                    currentObject = invokeMethod(currentObject, methodName);
                }
            } else {
                // It's a field access
                currentObject = getFieldValue(currentObject, field);
            }
        }

        return currentObject.toString();
    }

    /**
     * Gets the field value from an object using reflection.
     *
     * @param obj   The object to get the field value from.
     * @param field The field name.
     * @return The field value.
     * @throws Exception If there is an error accessing the field.
     */
    public static Object getFieldValue(Object obj, String field) throws Exception {
        Field declaredField = obj.getClass().getDeclaredField(field);
        declaredField.setAccessible(true);
        return declaredField.get(obj);
    }

    /**
     * Invokes a method on an object using reflection.
     *
     * @param obj        The object on which to invoke the method.
     * @param methodName The name of the method to invoke.
     * @return The result of the method invocation.
     * @throws Exception If there is an error invoking the method.
     */
    public static Object invokeMethod(Object obj, String methodName) throws Exception {
        Method method = obj.getClass().getMethod(methodName);
        return method.invoke(obj);
    }

    /**
     * Invokes the size method on a List or Map object.
     *
     * @param obj The List or Map object.
     * @return The size of the List or Map.
     * @throws Exception If there is an error invoking the method.
     */
    public static Object invokeSizeMethod(Object obj) throws Exception {
        if (obj instanceof List) {
            return ((List<?>) obj).size();
        } else if (obj instanceof Map) {
            return ((Map<?, ?>) obj).size();
        } else {
            throw new IllegalArgumentException("Object is not a List or Map");
        }
    }
